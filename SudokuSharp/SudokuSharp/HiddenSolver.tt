<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
using System;

namespace SudokuSharp
{
    public static class HiddenSolver
    {
        public static bool Solve(Cell[] cells)
        {
            Span<int> possBuf = stackalloc int[27];
            Span<int> possRows = possBuf.Slice(0, 9);
            Span<int> possCols = possBuf.Slice(9, 9);
            Span<int> possBoxRows = possBuf.Slice(18, 9);
            bool changed = false;
            for (int major = 0; major < 9; major++)
            {
				int any, ovr, uniqs;
<#
	string[] iterators = new[] { "Rows", "Cols", "BoxRows" };
	foreach (string iterator in iterators) {
#>
				// <#= iterator #>
                any = 0; // bit is 1 if any cells have that possibility
                ovr = 0; // bit is 1 once a second cell has it
                for (int minor = 0; minor < 9; minor++)
                {
                    int i = Solver.<#= iterator #>Index(major, minor);
                    Cell cell = cells[i];
                    int pos = cell.Possible;
                    if (cell.Value != Cell.Unknown)
                    {
                        // value already exists, take it out of contention
                        poss<#= iterator #>[minor] = 0;
                        ovr |= pos;
                    }
                    else
                    {
                        poss<#= iterator #>[minor] = pos;
                        ovr |= any & pos;
                    }
                    any |= pos;
                }
                uniqs = any ^ ovr;
                if (uniqs != 0)
                {
                    // there are bits in any that are not in ovr
                    // second pass, find cells with unique possibles
                    for (int minor = 0; minor < 9; minor++)
                    {
                        int p = poss<#= iterator #>[minor] & uniqs;
                        if (p != 0)
                        {
                            // cell has unique possible
                            int i = Solver.<#= iterator #>Index(major, minor);
                            cells[i].Possible = p;
                            changed |= cells[i].CheckPossible();
                        }
                    }
                }
<#
	}
#>
            }
            return changed;
        }
    }
}